// Getter is a tool to automate the creation of getter and setter methods for each unexported field
// in a struct
// Mostly copied from stringer.go

package main // import "bramp.net/dsector/tools/getter"

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/format"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"
)

var (
	typeNames = flag.String("type", "", "comma-separated list of type names; must be set")
	extends   = flag.String("extends", "derives", "TODO REMOVE - use special extends getter")

	header1 = "// Code generated by \"getter "
	header2 = "\"; DO NOT EDIT\n"
)

// Usage is a replacement usage function for the flags package.
func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "\tgetter [flags] -type T [directory]\n")
	fmt.Fprintf(os.Stderr, "\tgetter [flags] -type T files... # Must be a single package\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("getter: ")
	flag.Usage = Usage
	flag.Parse()
	if len(*typeNames) == 0 {
		flag.Usage()
		os.Exit(2)
	}
	types := strings.Split(*typeNames, ",")

	// We accept either one directory or a list of files. Which do we have?
	args := flag.Args()
	if len(args) == 0 {
		// Default: process whole package in current directory.
		args = []string{"."}
	}

	// Parse the package once.
	var (
		g Generator
	)
	if len(args) == 1 && isDirectory(args[0]) {
		g.dir = args[0]
		g.parsePackageDir(args[0])
	} else {
		g.dir = filepath.Dir(args[0])
		g.parsePackageFiles(args)
	}

	// Run generate for each type.
	g.generate(types)
}

// isDirectory reports whether the named file is a directory.
func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf bytes.Buffer // Accumulated output.
	pkg *Package     // Package we are scanning.
	dir string
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

type Struct struct {
	name string        // Struct's name
	s    *types.Struct // The struct
}

type Method struct {
	receiver string // Receiver type
	name     string // Method name
}

// File holds a single parsed file and associated data.
type File struct {
	name string    // Filename
	pkg  *Package  // Package to which this file belongs.
	file *ast.File // Parsed AST.
	// These fields are reset for each type being generated.

	types []string // Types being looked for.

	structs []*Struct // The structs in this file
	methods []*Method // The method in this file
}

type Package struct {
	dir    string
	name   string
	defs   map[*ast.Ident]types.Object
	scopes map[ast.Node]*types.Scope
	types  map[ast.Expr]types.TypeAndValue

	files    []*File
	methods  []*Method
	typesPkg *types.Package
}

// parsePackageDir parses the package residing in the directory.
func (g *Generator) parsePackageDir(directory string) {
	pkg, err := build.Default.ImportDir(directory, 0)
	if err != nil {
		log.Fatalf("cannot process directory %s: %s", directory, err)
	}
	var names []string
	names = append(names, pkg.GoFiles...)
	names = append(names, pkg.CgoFiles...)
	// TODO: Need to think about constants in test files. Maybe write type_string_test.go
	// in a separate pass? For later.
	// names = append(names, pkg.TestGoFiles...) // These are also in the "foo" package.
	names = append(names, pkg.SFiles...)
	names = prefixDirectory(directory, names)
	g.parsePackage(directory, names, nil)
}

// parsePackageFiles parses the package occupying the named files.
func (g *Generator) parsePackageFiles(names []string) {
	g.parsePackage(".", names, nil)
}

// prefixDirectory places the directory name on the beginning of each name in the list.
func prefixDirectory(directory string, names []string) []string {
	if directory == "." {
		return names
	}
	ret := make([]string, len(names))
	for i, name := range names {
		ret[i] = filepath.Join(directory, name)
	}
	return ret
}

// parsePackage analyzes the single package constructed from the named files.
// If text is non-nil, it is a string to be used instead of the content of the file,
// to be used for testing. parsePackage exits if there is an error.
func (g *Generator) parsePackage(directory string, names []string, text interface{}) {
	var files []*File
	var astFiles []*ast.File
	g.pkg = new(Package)
	fs := token.NewFileSet()
	for _, name := range names {
		if !strings.HasSuffix(name, ".go") {
			continue
		}
		parsedFile, err := parser.ParseFile(fs, name, text, 0)
		if err != nil {
			log.Fatalf("parsing package: %s: %s", name, err)
		}
		if len(astFiles) > 0 {
			// TODO We assume all files are from the same package.
			if parsedFile.Name.Name != g.pkg.name {
				log.Fatalf("files from different packages are not supported: %s vs %s", astFiles[0].Name.Name, g.pkg.name)
			}
		}
		astFiles = append(astFiles, parsedFile)
		files = append(files, &File{
			name: name,
			file: parsedFile,
			pkg:  g.pkg,
		})
		g.pkg.name = parsedFile.Name.Name
	}
	if len(astFiles) == 0 {
		log.Fatalf("%s: no buildable Go files", directory)
	}
	g.pkg.files = files
	g.pkg.dir = directory

	// Type check the package.
	g.pkg.check(fs, astFiles)
}

// check type-checks the package. The package must be OK to proceed.
func (pkg *Package) check(fs *token.FileSet, astFiles []*ast.File) {
	pkg.defs = make(map[*ast.Ident]types.Object)
	pkg.scopes = make(map[ast.Node]*types.Scope)
	pkg.types = make(map[ast.Expr]types.TypeAndValue)

	config := types.Config{Importer: importer.Default(), FakeImportC: true}
	info := &types.Info{
		Defs:   pkg.defs,
		Scopes: pkg.scopes,
		Types:  pkg.types,
	}
	typesPkg, err := config.Check(pkg.dir, fs, astFiles, info)
	if err != nil {
		log.Fatalf("checking package: %s", err)
	}
	pkg.typesPkg = typesPkg
}

func (g *Generator) clear() {
	g.buf.Reset()
}

// funcDecl builds up an index of all Methods
func (f *File) funcDecl(node ast.Node) bool {
	decl, ok := node.(*ast.FuncDecl)
	if !ok {
		return true // We only care about function declarations.
	}

	if decl.Recv != nil {
		receiver, ok := f.pkg.types[decl.Recv.List[0].Type]
		if !ok {
			log.Fatalf("no value for receiver type %s", decl.Recv.List[0].Type)
		}

		receiverName := ""
		if p, ok := receiver.Type.(*types.Pointer); ok {
			receiverName = p.Elem().(*types.Named).Obj().Name()
		} else if n, ok := receiver.Type.(*types.Named); ok {
			receiverName = n.Obj().Name()
		} else {
			log.Fatal("receiver is not Pointer or Named types")
		}

		m := &Method{receiver: receiverName, name: decl.Name.String()}
		f.methods = append(f.methods, m)
	}

	f.pkg.methods = append(f.pkg.methods, f.methods...)

	return true
}

// genDecl builds an index of all structs we are interested in
func (f *File) genDecl(node ast.Node) bool {
	decl, ok := node.(*ast.GenDecl)
	if !ok || decl.Tok != token.TYPE {
		// We only care about type declarations.
		return true
	}

	// Loop over the elements of the declaration.
	for _, spec := range decl.Specs {
		tspec := spec.(*ast.TypeSpec) // Guaranteed to succeed as this is TYPE.

		if !contains(f.types, tspec.Name.Name) {
			// This is not the type we're looking for.
			continue
		}

		obj, ok := f.pkg.defs[tspec.Name]
		if !ok {
			log.Fatalf("no value for type %s", tspec.Name)
		}
		s, ok := obj.Type().Underlying().(*types.Struct)
		if !ok {
			log.Fatalf("can't handle non-struct type %T", obj.Type().Underlying())
		}

		f.structs = append(f.structs, &Struct{name: tspec.Name.Name, s: s})
	}

	return false
}

// generate produces the Getter and Setter methods for the named type.
func (g *Generator) generate(structs []string) {

	for _, file := range g.pkg.files {
		file.types = structs
		ast.Inspect(file.file, file.funcDecl)
		ast.Inspect(file.file, file.genDecl)
	}

	for _, file := range g.pkg.files {

		// Write to file.
		baseName := strings.TrimSuffix(file.name, ".go")
		outputName := fmt.Sprintf("%s_getters.go", baseName)

		if f, err := os.Open(outputName); err == nil {
			generated, err := isGeneratedFile(f)
			if err != nil {
				log.Fatalf("reading existing output file: %s", err)
			}

			if !generated {
				log.Fatalf("will not override files not generated by me")
			}
		}

		outputFile := findFile(g.pkg.files, outputName)

		g.clear()
		fields := g.print(file, outputFile)

		if fields == 0 {
			// No fields need writing out
			continue
		}

		// Format the output.
		src := g.format()

		if err := ioutil.WriteFile(outputName, src, 0644); err != nil {
			log.Fatalf("writing output: %s", err)
		}
	}
}

type VarTag struct {
	Var *types.Var
	Tag reflect.StructTag
}

// listFields returns all fields, and tags within this struct and all embedded structs
func listFields(s *types.Struct) []*VarTag {
	var fields []*VarTag

	for i := 0; i < s.NumFields(); i++ {
		field := s.Field(i)
		tag := s.Tag(i)
		if t, ok := field.Type().(*types.Named); ok {
			if ss, ok := t.Underlying().(*types.Struct); ok {
				fields = append(fields, listFields(ss)...)
			}
		}

		// Skip exported fields as they don't need getters.
		if field.Exported() {
			continue
		}

		fields = append(fields, &VarTag{Var: field, Tag: reflect.StructTag(tag)})
	}

	return fields
}

func (g *Generator) print(file *File, outputFile *File) int {

	pkg := file.pkg
	fieldCount := 0

	// Print the header and package clause.
	g.Printf("%s%s%s", header1, strings.Join(os.Args[1:], " "), header2)
	g.Printf("\n")
	g.Printf("package %s", g.pkg.name)
	g.Printf("\n\n")

	sort.Sort(byStructName(file.structs))

	for _, s := range file.structs {
		fields := listFields(s.s)

		sort.Sort(byName(fields))
		qual := types.RelativeTo(g.pkg.typesPkg)

		// Map of fields in this struct
		fieldsMap := make(map[string]bool)
		for _, field := range fields {
			fieldsMap[field.Var.Name()] = true
		}

		for _, field := range fields {
			fieldName := field.Var.Name()
			fieldType := types.TypeString(field.Var.Type(), qual)
			zeroValue := zero(field.Var.Type(), qual)
			structName := s.name
			letter := strings.ToLower(structName[:1])

			getter := true
			if tag, ok := field.Tag.Lookup("getter"); ok && tag == "false" {
				getter = false
			}

			setter := true
			if tag, ok := field.Tag.Lookup("setter"); ok && tag == "false" {
				setter = false
			}

			defaultValue := zeroValue
			if tag, ok := field.Tag.Lookup("default"); ok {
				defaultValue = tag
			}

			dereference := ""
			reference := ""
			if _, ok := field.Tag.Lookup("dereference"); ok {
				dereference = "*"
				reference = "&"

				// TODO Check fieldType is a pointer
				fieldType = fieldType[1:] // Remove the star infront of the pointer
			}

			// Only write the method if the method doesn't already exist in
			// this package, outside of the file we are about to override.
			methodName := strings.Title(fieldName)

			if getter {
				if *extends != "" {
					// TODO And this struct actually has an extends method
					if fieldName == *extends || fieldName == "parent" {
						continue
					}

					useParent := true
					if tag, ok := field.Tag.Lookup("parent"); ok && tag == "false" {
						useParent = false
					}

					useExtends := true
					if tag, ok := field.Tag.Lookup(*extends); ok && tag == "false" {
						useExtends = false
					}

					// Extending Getter
					if !methodExists(pkg.methods, s.name, methodName) || methodExists(outputFile.methods, s.name, methodName) {
						g.Printf("func (%s *%s) %s() %s {\n", letter, structName, methodName, fieldType)
						g.Printf("    if %s.%s != %s {\n", letter, fieldName, zeroValue)
						g.Printf("        return %s%s.%s\n", dereference, letter, fieldName)
						g.Printf("    }\n")

						if useExtends && fieldsMap[*extends] {
							// TODO Check type of Extends
							g.Printf("    if %s.%s != nil {\n", letter, *extends)
							g.Printf("        return %s.%s.%s()\n", letter, *extends, methodName)
							g.Printf("    }\n")
						}
						if useParent && fieldsMap["parent"] && methodExists(pkg.methods, "Structure", methodName) {
							// TODO Store the field type
							g.Printf("    if %s.parent != nil {\n", letter)
							g.Printf("        return %s.parent.%s()\n", letter, methodName)
							g.Printf("    }\n")
						}

						g.Printf("    return %s\n", defaultValue)
						g.Printf("}\n\n")

						fieldCount++
					}
				} else {

					// Simple Getter
					if !methodExists(file.pkg.methods, s.name, methodName) || methodExists(outputFile.methods, s.name, methodName) {
						g.Printf("func (%s *%s) %s() %s {\n", letter, structName, methodName, fieldType)
						g.Printf("    return %s.%s\n", letter, fieldName)
						g.Printf("}\n\n")

						fieldCount++
					}
				}
			}

			if setter {
				methodName = "Set" + methodName
				argName := fieldName
				if argName == letter {
					argName += letter
				}

				// If the method doesn't exist, or does exist but in the file we are currently replacing.
				if !methodExists(file.pkg.methods, s.name, methodName) || methodExists(outputFile.methods, s.name, methodName) {
					g.Printf("func (%s *%s) %s(%s %s) {\n", letter, structName, methodName, argName, fieldType)
					g.Printf("    %s.%s = %s%s\n", letter, fieldName, reference, argName)
					g.Printf("}\n\n")

					fieldCount++
				}
			}
		}
	}

	return fieldCount
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

// zero returns a string representation of this type's zero value.
func zero(typ types.Type, qf types.Qualifier) string {
	switch t := typ.(type) {
	case *types.Basic:
		if (t.Info() & types.IsNumeric) > 0 {
			//return types.TypeString(typ, nil) + "(0)"
			return "0"
		}
		if (t.Info() & types.IsBoolean) > 0 {
			return "false"
		}
		if (t.Info() & types.IsString) > 0 {
			return `""`
		}

		log.Fatalf("BUG: Unhandled basic type: %s", typ.String())
		return ""

	case *types.Named:
		// TODO if this is enum type, then return the enum name, instead of "TYPE(0)"

		if _, ok := t.Underlying().(*types.Struct); ok {
			return "(" + types.TypeString(typ, qf) + "{})"
		}
		return t.Obj().Name() + "(" + zero(t.Underlying(), qf) + ")"

	//case *types.Struct:
	//	return "(struct{}{})" // TODO Implement this

	case *types.Array:
		return t.String() + "{}"

	case *types.Slice, *types.Pointer, *types.Interface, *types.Map, *types.Chan, *types.Signature:
		return "nil"
	}

	log.Fatalf("BUG: Unhandled type: %v %T", typ, typ)
	return ""
}

// isGeneratedFile checks if the file already exists and is generated by us
func isGeneratedFile(f *os.File) (bool, error) {
	r := bufio.NewReader(f)
	line, err := r.ReadString('\n')
	if err == io.EOF {
		return false, nil
	}
	if err != nil {
		return false, err
	}

	return strings.Contains(line, header1) && strings.Contains(line, header2), nil
}

func methodExists(methods []*Method, structName, methodName string) bool {
	for _, m := range methods {
		if m.name == methodName && m.receiver == structName {
			return true
		}
	}
	return false
}

func findFile(files []*File, filename string) *File {
	for _, f := range files {
		if f.name == filename {
			return f
		}
	}
	return nil
}

// byValue lets us sort the constants into increasing order.
type byName []*VarTag

func (b byName) Len() int           { return len(b) }
func (b byName) Swap(i, j int)      { b[i], b[j] = b[j], b[i] }
func (b byName) Less(i, j int) bool { return b[i].Var.Name() < b[j].Var.Name() }

type byStructName []*Struct

func (b byStructName) Len() int           { return len(b) }
func (b byStructName) Swap(i, j int)      { b[i], b[j] = b[j], b[i] }
func (b byStructName) Less(i, j int) bool { return b[i].name < b[j].name }

func contains(haystack []string, needle string) bool {
	for _, straw := range haystack {
		if straw == needle {
			return true
		}
	}
	return false
}
